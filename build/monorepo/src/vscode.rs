use std::io::Write;

use guppy::graph::{BuildTargetId, BuildTargetKind};
use lgn_tracing::span_fn;
use serde_json::{json, to_string_pretty};

use crate::{context::Context, Error, Result};

#[derive(Debug, clap::Args)]
pub struct Args {
    #[clap(long, short)]
    force: bool,
}

#[allow(clippy::too_many_lines)]
#[span_fn]
pub fn run(args: &Args, ctx: &Context) -> Result<()> {
    let bin_packages: Vec<_> = ctx
        .package_graph()?
        .workspace()
        .iter()
        .filter(|package| {
            package.build_targets().any(|bt| {
                bt.kind() == BuildTargetKind::Binary && matches!(bt.id(), BuildTargetId::Binary(_))
            })
        })
        .collect();

    let mut tasks = vec![];
    tasks.push(json!({
        "type": "cargo",
        "command": "mclippy",
        "args": [
            "--workspace",
        ],
        "problemMatcher": [
            "$rustc"
        ],
        "group": {
            "kind": "build",
            "isDefault": true
        },
        "label": "Run Clippy",
    }));
    let mut configurations = vec![];
    for package in bin_packages {
        for target in package.build_targets() {
            if let BuildTargetId::Binary(name) = target.id() {
                let label = format!("build: {}", name);
                tasks.push(json!({
                    "type": "cargo",
                    "command": "mbuild",
                    "args": [
                        "--package",
                        package.name(),
                        "--bin",
                        name,
                    ],
                    "problemMatcher": [
                        "$rustc"
                    ],
                    "label": label,
                }));
                configurations.push(json!({
                    "name": name,
                    "type": "cppvsdbg",
                    "request": "launch",
                    "program": format!("${{workspaceFolder}}/target/debug/{}.exe", name),
                    "args": [],
                    "stopAtEntry": false,
                    "cwd": "${workspaceFolder}",
                    "environment": [],
                    "console": "internalConsole",
                    "sourceFileMap": {
                        "/rustc/02072b482a8b5357f7fb5e5637444ae30e423c40": "/Scoop/user/persist/rustup-msvc/.rustup/toolchains/1.58.0-x86_64-pc-windows-msvc/lib/rustlib/src/rust"
                    },
                    "symbolSearchPath": "https://msdl.microsoft.com/download/symbols",
                    "preLaunchTask": label,
                }));
            }
        }
    }

    let tasks_file = ctx.workspace_root().join(".vscode").join("tasks.json");
    let tasks = json!({
        "version": "2.0.0",
        "tasks": &tasks,
    });

    let launch_file = ctx.workspace_root().join(".vscode").join("launch.json");
    // hardcoded for now
    let launch = json!({
        "version": "0.2.0",
        "compounds": [
            {
                "name": "editor-compound",
                "configurations": [
                    "editor-client",
                    "editor-srv",
                ],
            }
        ],
        "configurations": configurations,
    });
    for (file, content) in &[(tasks_file, tasks), (launch_file, launch)] {
        let comment = "// This file is generated by monorepo tooling. Do not edit.";

        if std::fs::metadata(file).is_ok() {
            let generated = std::fs::read_to_string(file)
                .map_err(|e| Error::new("").with_source(e))?
                .starts_with(comment);

            if !generated && !args.force {
                return Err(Error::new(format!(
                    "Non generated file already exists: {}. Use --force to overwrite.",
                    file
                )));
            }
        }

        let mut file = std::fs::File::create(file)
            .map_err(|e| Error::new("failed to create file").with_source(e))?;

        let json = to_string_pretty(&content)
            .map_err(|e| Error::new("failed to print json").with_source(e))?;

        file.write_all(comment.as_bytes())
            .and_then(|_res| file.write_all(b"\n"))
            .and_then(|_res| file.write_all(json.as_bytes()))
            .map_err(|e| Error::new("failed to write json file").with_source(e))?;
    }

    Ok(())
}
