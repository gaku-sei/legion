use std::io::Write;

use guppy::graph::{BuildTargetId, BuildTargetKind};
use lgn_tracing::span_fn;
use serde_json::{json, to_string_pretty};

use crate::{config::HostConfig, context::Context, Error, Result};

#[derive(Debug, clap::Args)]
pub struct Args {
    #[clap(long, short)]
    force: bool,
}

#[allow(clippy::too_many_lines)]
#[span_fn]
pub fn run(args: &Args, ctx: &Context) -> Result<()> {
    let workspace = ctx.package_graph()?.workspace();
    let bin_packages: Vec<_> = workspace
        .iter()
        .filter(|package| {
            package.build_targets().any(|bt| {
                bt.kind() == BuildTargetKind::Binary && matches!(bt.id(), BuildTargetId::Binary(_))
            })
        })
        .collect();
    let debugger_type = ctx
        .config()
        .vscode
        .debugger_type
        .as_ref()
        .map_or("lldb", HostConfig::as_str);

    for package in ctx.config().vscode.overrides.keys() {
        if !workspace.contains_name(package) {
            return Err(Error::new(format!(
                "override {} is not in the workspace",
                package
            )));
        }
    }

    let mut tasks = vec![];
    tasks.push(json!({
        "type": "cargo",
        "command": "vsclippy",
        "args": [
            "--workspace",
        ],
        "problemMatcher": [
            "$rustc"
        ],
        "group": {
            "kind": "build",
            "isDefault": true
        },
        "label": "Run Clippy",
    }));
    let mut configurations = vec![];
    for package in bin_packages {
        for target in package.build_targets() {
            if let BuildTargetId::Binary(name) = target.id() {
                let label = format!("build: {}", name);
                tasks.push(json!({
                    "type": "cargo",
                    "command": "mbuild",
                    "args": [
                        "--package",
                        package.name(),
                        "--bin",
                        name,
                    ],
                    "problemMatcher": [
                        "$rustc"
                    ],
                    "label": label,
                }));
                configurations.push(json!({
                    "name": name,
                    "type": debugger_type,
                    "request": "launch",
                    "program": format!("${{workspaceFolder}}/target/debug/{}.exe", name),
                    "args": ctx.config().vscode.overrides.get(package.name()).map_or_else(
                        std::vec::Vec::new,
                        |dict| dict.get("args").unwrap_or(&vec![]).clone()
                    ),
                    "stopAtEntry": false,
                    "cwd": "${workspaceFolder}",
                    "environment": [],
                    "console": "internalConsole",
                    "sourceFileMap": {
                        "/rustc/02072b482a8b5357f7fb5e5637444ae30e423c40": "/Scoop/user/persist/rustup-msvc/.rustup/toolchains/1.58.0-x86_64-pc-windows-msvc/lib/rustlib/src/rust"
                    },
                    "symbolSearchPath": "https://msdl.microsoft.com/download/symbols",
                    "preLaunchTask": label,
                }));
            }
        }
    }

    let tasks_file = ctx.workspace_root().join(".vscode").join("tasks.json");
    let tasks = json!({
        "version": "2.0.0",
        "tasks": &tasks,
    });
    let mut compounds = vec![];
    for (name, config) in &ctx.config().vscode.compounds {
        compounds.push(json!({
            "name": name,
            "configurations": config,
        }));
    }
    let launch_file = ctx.workspace_root().join(".vscode").join("launch.json");
    // hardcoded for now
    let launch = json!({
        "version": "0.2.0",
        "compounds": compounds,
        "configurations": configurations,
    });
    for (file, content) in &[(tasks_file, tasks), (launch_file, launch)] {
        let comment = "// This file is generated by monorepo tooling. Do not edit.";

        if std::fs::metadata(file).is_ok() {
            let generated = std::fs::read_to_string(file)
                .map_err(|e| Error::new("").with_source(e))?
                .starts_with(comment);

            if !generated && !args.force {
                return Err(Error::new(format!(
                    "Non generated file already exists: {}. Use --force to overwrite.",
                    file
                )));
            }
        }

        let mut file = std::fs::File::create(file)
            .map_err(|e| Error::new("failed to create file").with_source(e))?;

        let json = to_string_pretty(&content)
            .map_err(|e| Error::new("failed to print json").with_source(e))?;

        file.write_all(comment.as_bytes())
            .and_then(|_res| file.write_all(b"\n"))
            .and_then(|_res| file.write_all(json.as_bytes()))
            .map_err(|e| Error::new("failed to write json file").with_source(e))?;
    }

    Ok(())
}
