use std::{
    collections::HashMap,
    task::{Context, Poll},
};

use dyn_clone::DynClone;
use log::{debug, info};
use tonic::transport::NamedService;

pub trait MultiplexableService: DynClone {
    fn call(
        &mut self,
        req: http::Request<hyper::Body>,
    ) -> BoxFuture<http::Response<tonic::body::BoxBody>, tonic::codegen::Never>;
}

dyn_clone::clone_trait_object!(MultiplexableService);

// Blanket implementation for all services: makes it possible to use all tonic-generated services
// in the `Multiplexer` service.
impl<S> MultiplexableService for S
where
    S: tower::Service<http::Request<hyper::Body>> + Clone,
    S::Future: Into<BoxFuture<http::Response<tonic::body::BoxBody>, tonic::codegen::Never>>,
{
    fn call(
        &mut self,
        req: http::Request<hyper::Body>,
    ) -> BoxFuture<http::Response<tonic::body::BoxBody>, tonic::codegen::Never> {
        S::call(self, req).into()
    }
}

type BoxMultiplexableService = Box<dyn MultiplexableService + Send + Sync>;

#[derive(Default, Clone)]
struct Services(HashMap<&'static str, BoxMultiplexableService>);

impl Services {
    fn new() -> Self {
        Self(HashMap::new())
    }

    fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    fn get_mut(&mut self, svc_name: &str) -> Option<&mut BoxMultiplexableService> {
        self.0.get_mut(svc_name)
    }

    fn add_service<S>(&mut self, s: S)
    where
        S: MultiplexableService + NamedService + Send + Sync + 'static,
    {
        self.0.insert(S::NAME, Box::new(s));
    }
}

/// A helper type to construct `MultiplexerService` instances.
#[derive(Default, Clone)]
pub struct MultiplexerServiceBuilder {
    services: Services,
}

impl MultiplexerServiceBuilder {
    fn new() -> Self {
        Self {
            services: Services::new(),
        }
    }

    /// Add a `gRPC` service to route traffic to.
    ///
    /// This call expects a service as generated by the `tonic` crate.
    pub fn add_service<S>(&mut self, s: S) -> &mut Self
    where
        S: MultiplexableService + NamedService + Send + Sync + 'static,
    {
        info!("registered service `{}`", S::NAME);

        self.services.add_service(s);

        self
    }

    /// Build a `MultiplexerService` only if it has at least one service to route traffic to.
    pub fn build(&self) -> Option<MultiplexerService> {
        if self.services.is_empty() {
            None
        } else {
            Some(MultiplexerService::new(self.services.clone()))
        }
    }
}

/// Multiplexer is a routing service that can dynamically be extended with new `gRPC` services at
/// runtime.
#[derive(Default, Clone)]
pub struct MultiplexerService {
    services: Services,
}

impl MultiplexerService {
    pub fn builder() -> MultiplexerServiceBuilder {
        MultiplexerServiceBuilder::new()
    }

    fn new(services: Services) -> Self {
        Self { services }
    }
}

type BoxFuture<T, E> =
    std::pin::Pin<Box<dyn std::future::Future<Output = Result<T, E>> + Send + 'static>>;

impl tower::Service<http::Request<hyper::Body>> for MultiplexerService {
    type Response = http::Response<tonic::body::BoxBody>;

    type Error = tonic::codegen::Never;

    type Future = BoxFuture<Self::Response, Self::Error>;

    fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }

    fn call(&mut self, req: http::Request<hyper::Body>) -> Self::Future {
        if let Some(content_type) = req.headers().get("content-type") {
            let content_type = content_type.to_str().unwrap_or_default();

            if content_type.starts_with("application/grpc") {
                if let Some(svc_name) = req.uri().path().splitn(3, '/').nth(1) {
                    match &mut self.services.get_mut(svc_name) {
                        Some(svc) => {
                            debug!("dispatching call to service `{}`", svc_name);

                            svc.call(req)
                        }
                        None => {
                            debug!(
                                "cannot dispatch call to unregistered service `{}`",
                                svc_name
                            );

                            Box::pin(futures_util::future::ok(
                                http::Response::builder()
                                    .status(http::StatusCode::OK)
                                    .header("grpc-status", tonic::Code::Unimplemented.to_string())
                                    .header("content-type", "application/grpc")
                                    .body(tonic::body::empty_body())
                                    .unwrap(),
                            ))
                        }
                    }
                } else {
                    debug!(
                        "failed to dispatch call to service: the request path does not seem to contain a service name ({})",
                        req.uri().path(),
                    );

                    Box::pin(futures_util::future::ok(
                        http::Response::builder()
                            .status(http::StatusCode::NOT_FOUND)
                            .body(tonic::body::empty_body())
                            .unwrap(),
                    ))
                }
            } else {
                debug!(
                    "rejecting HTTP call with no gRPC content-type `{}`",
                    content_type,
                );

                Box::pin(futures_util::future::ok(
                    http::Response::builder()
                        .status(http::StatusCode::UNSUPPORTED_MEDIA_TYPE)
                        .body(tonic::body::empty_body())
                        .unwrap(),
                ))
            }
        } else {
            debug!("rejecting HTTP call with no content-type specified");

            Box::pin(futures_util::future::ok(
                http::Response::builder()
                    .status(http::StatusCode::BAD_REQUEST)
                    .body(tonic::body::empty_body())
                    .unwrap(),
            ))
        }
    }
}

impl NamedService for MultiplexerService {
    const NAME: &'static str = "";
}
