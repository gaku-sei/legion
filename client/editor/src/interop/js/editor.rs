//! This module provides interop types between the `gRPC` protocol and the types used in the
//! Javascript frontend.
//!
//! Most of the structures here are 1:1 mappings of the `gRPC` protocol ones, which at first could
//! seem like a non-sensical thing.
//!
//! Note however that:
//!
//! - The `gRPC` generated types are not JSON serializable/deserializable and we can't just
//! implement the `serde` traits on them.
//! - The two protocols: one between the Javascript and the native Tauri client and the other
//! between the native Tauri client and the Editor server **do not have to be the same**. They can
//! be, but that's not mandatory. Actually, we could totally imagine a case where the Javascript
//! needs some extra fields or a different layout from the one generated by `gRPC` for its
//! implementation to be maintainable or effective. Just because it's not the case right now
//! doesn't mean it will always be like that. That abstraction protects us from that.
//!
//! In any case, maintaining the mappings below should not be a huge burden and very straighforward
//! in most cases.

use serde::{Deserialize, Serialize};

use legion_editor_proto::ResourceDescription;

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSSearchResourcesResponse {
    pub resource_descriptions: Vec<JSResourceDescription>,
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSResourceDescription {
    pub id: String,
    pub path: String,
    pub version: u32,
}

impl From<ResourceDescription> for JSResourceDescription {
    fn from(v: ResourceDescription) -> Self {
        Self {
            id: v.id,
            path: v.path,
            version: v.version,
        }
    }
}
