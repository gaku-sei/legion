//! This module provides interop types between the `gRPC` protocol and the types used in the
//! Javascript frontend.
//!
//! Most of the structures here are 1:1 mappings of the `gRPC` protocol ones, which at first could
//! seem like a non-sensical thing.
//!
//! Note however that:
//!
//! - The `gRPC` generated types are not JSON serializable/deserializable and we can't just
//! implement the `serde` traits on them.
//! - The two protocols: one between the Javascript and the native Tauri client and the other
//! between the native Tauri client and the Editor server **do not have to be the same**. They can
//! be, but that's not mandatory. Actually, we could totally imagine a case where the Javascript
//! needs some extra fields or a different layout from the one generated by `gRPC` for its
//! implementation to be maintainable or effective. Just because it's not the case right now
//! doesn't mean it will always be like that. That abstraction protects us from that.
//!
//! In any case, maintaining the mappings below should not be a huge burden and very straighforward
//! in most cases.

use serde::{Deserialize, Serialize};

use legion_editor_proto::{GetResourcePropertiesResponse, ResourceDescription, ResourceProperty};

pub trait IntoVec<T> {
    fn into_vec(self) -> Vec<T>;
}

impl<F, T> IntoVec<T> for Vec<F>
where
    F: Into<T>,
{
    fn into_vec(self) -> Vec<T> {
        self.into_iter().map(Into::into).collect()
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSSearchResourcesResponse {
    pub resource_descriptions: Vec<JSResourceDescription>,
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSGetResourcePropertiesResponse {
    pub description: JSResourceDescription,
    pub properties: Vec<JSResourceProperty>,
}

impl From<GetResourcePropertiesResponse> for JSGetResourcePropertiesResponse {
    fn from(v: GetResourcePropertiesResponse) -> Self {
        Self {
            description: v.description.unwrap_or_default().into(),
            properties: v.properties.into_vec(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSResourceDescription {
    pub id: String,
    pub path: String,
    pub version: u32,
}

impl From<ResourceDescription> for JSResourceDescription {
    fn from(v: ResourceDescription) -> Self {
        Self {
            id: v.id,
            path: v.path,
            version: v.version,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct JSResourceProperty {
    pub name: String,
    pub ptype: String,
    pub default_value: Vec<u8>,
    pub value: Vec<u8>,
    pub group: String,
}

impl From<ResourceProperty> for JSResourceProperty {
    fn from(v: ResourceProperty) -> Self {
        Self {
            name: v.name,
            ptype: v.ptype,
            default_value: v.default_value,
            value: v.value,
            group: v.group,
        }
    }
}
